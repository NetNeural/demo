'use client'

import { useState, useEffect } from 'react'
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter } from '@/components/ui/dialog'
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'
import { Textarea } from '@/components/ui/textarea'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'
import { Loader2, CheckCircle, XCircle, Copy, ExternalLink, FileCode } from 'lucide-react'
import { edgeFunctions } from '@/lib/edge-functions'
import { toast } from 'sonner'
import { integrationService } from '@/services/integration.service'

interface WebhookConfig {
  id?: string
  name: string
  url: string
  secret?: string
  custom_headers?: string
  trigger_events?: string[]
}

interface Props {
  open: boolean
  onOpenChange: (open: boolean) => void
  integrationId?: string
  organizationId: string
  onSaved?: () => void
  mode?: 'dialog' | 'page'
}

export function WebhookConfigDialog({ 
  open, 
  onOpenChange, 
  integrationId, 
  organizationId,
  onSaved,
  mode = 'dialog'
}: Props) {
  const [loading, setLoading] = useState(false)
  const [testing, setTesting] = useState(false)
  const [testResult, setTestResult] = useState<{ success: boolean; message: string } | null>(null)
  
  const [config, setConfig] = useState<WebhookConfig>({
    name: 'Custom Webhook Integration',
    url: '',
    secret: '',
    custom_headers: '',
    trigger_events: ['device.created', 'device.updated', 'device.deleted', 'device.status_changed'],
  })

  const [generatedApiKey, setGeneratedApiKey] = useState<string>('')

  // Generate API key on mount for new integrations
  useEffect(() => {
    if (!integrationId && !generatedApiKey) {
      // Generate a secure random API key
      const key = 'ntrl_' + Array.from(crypto.getRandomValues(new Uint8Array(32)))
        .map(b => b.toString(16).padStart(2, '0'))
        .join('')
      setGeneratedApiKey(key)
    }
  }, [integrationId, generatedApiKey])

  const copyToClipboard = (text: string) => {
    navigator.clipboard.writeText(text)
    toast.success('Copied to clipboard!')
  }

  const ourWebhookEndpoint = process.env.NEXT_PUBLIC_SUPABASE_URL 
    ? `${process.env.NEXT_PUBLIC_SUPABASE_URL}/functions/v1/integration-webhook`
    : 'https://your-project.supabase.co/functions/v1/integration-webhook'

  const openApiSpec = {
    openapi: '3.0.0',
    info: {
      title: 'NetNeural Webhook Receiver API',
      version: '1.0.0',
      description: 'Webhook endpoint on NetNeural platform to receive events from external IoT platforms',
    },
    servers: [
      {
        url: ourWebhookEndpoint,
        description: 'NetNeural webhook receiver endpoint',
      },
    ],
    paths: {
      '/': {
        post: {
          summary: 'Receive webhook from external platform',
          description: 'This endpoint receives webhook events from external IoT platforms (Golioth, AWS IoT, etc.)',
          requestBody: {
            required: true,
            content: {
              'application/json': {
                schema: {
                  type: 'object',
                  properties: {
                    event: {
                      type: 'string',
                      enum: ['device.created', 'device.updated', 'device.deleted', 'device.status_changed', 'device.telemetry'],
                      description: 'Event type',
                    },
                    timestamp: {
                      type: 'string',
                      format: 'date-time',
                      description: 'Event timestamp',
                    },
                    device: {
                      type: 'object',
                      properties: {
                        id: { type: 'string', description: 'Device ID' },
                        name: { type: 'string', description: 'Device name' },
                        status: { type: 'string', description: 'Device status' },
                        metadata: { type: 'object', description: 'Device metadata' },
                      },
                    },
                  },
                },
              },
            },
          },
          parameters: [
            {
              name: 'X-Integration-ID',
              in: 'header',
              required: true,
              schema: {
                type: 'string',
              },
              description: 'Your integration ID from NetNeural (required to route webhook to correct integration)',
            },
            {
              name: 'X-Webhook-Signature',
              in: 'header',
              required: false,
              schema: {
                type: 'string',
              },
              description: 'HMAC SHA-256 signature of request body (required only if webhook secret is configured)',
            },
          ],
          responses: {
            '200': {
              description: 'Webhook received successfully',
            },
            '400': {
              description: 'Missing integration ID or malformed request',
            },
            '401': {
              description: 'Invalid signature (if secret is configured)',
            },
            '404': {
              description: 'Integration not found or webhook not enabled',
            },
          },
        },
      },
    },
    components: {
      schemas: {
        WebhookEvent: {
          type: 'object',
          required: ['event', 'timestamp'],
          properties: {
            event: {
              type: 'string',
              enum: ['device.created', 'device.updated', 'device.deleted', 'device.status_changed', 'device.telemetry'],
            },
            timestamp: {
              type: 'string',
              format: 'date-time',
            },
            device: {
              type: 'object',
              properties: {
                id: { type: 'string' },
                name: { type: 'string' },
                status: { type: 'string' },
                metadata: { type: 'object', additionalProperties: true },
              },
            },
          },
        },
      },
    },
  }

  useEffect(() => {
    if (integrationId && open) {
      loadConfig()
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [integrationId, open])

  const loadConfig = async () => {
    if (!integrationId) return

    setLoading(true)
    try {
      const response = await edgeFunctions.integrations.list(organizationId)
      
      if (!response.success) {
        throw new Error(typeof response.error === 'string' ? response.error : 'Failed to load integrations')
      }

      const integrations = (response.data as any)?.integrations || []
      const integration = integrations.find((i: any) => i.id === integrationId)

      if (integration) {
        const settings = integration.settings || {}
        setConfig({
          id: integration.id,
          name: integration.name,
          url: '', // Not used for receiving webhooks
          secret: settings.secret || '',
          custom_headers: '',
          trigger_events: [],
        })
      }
    } catch (error) {
      toast.error('Failed to load configuration')
      console.error(error)
    } finally {
      setLoading(false)
    }
  }

  const handleTest = async () => {
    if (!integrationId) {
      toast.error('Please save the configuration before testing')
      return
    }

    setTesting(true)
    setTestResult(null)

    try {
      const result: any = await integrationService.testIntegration(integrationId, 'webhook')
      setTestResult({
        success: result.success,
        message: result.message || 'Test webhook sent successfully'
      })
      
      if (result.success) {
        toast.success('Test webhook sent successfully!')
      } else {
        toast.error(result.message || 'Failed to send test webhook')
      }
    } catch (error) {
      const message = error instanceof Error ? error.message : 'Failed to send test webhook'
      setTestResult({ success: false, message })
      toast.error(message)
    } finally {
      setTesting(false)
    }
  }

  const handleSave = async () => {
    if (!config.name) {
      toast.error('Please enter an integration name')
      return
    }

    setLoading(true)
    try {
      const webhookConfig = {
        secret: config.secret,
        webhookEnabled: true,
      }

      let response
      if (integrationId) {
        response = await edgeFunctions.integrations.update(integrationId, {
          name: config.name,
          settings: webhookConfig,
          status: 'active',
        })
      } else {
        response = await edgeFunctions.integrations.create({
          organization_id: organizationId,
          integration_type: 'webhook',
          name: config.name,
          settings: webhookConfig,
        } as any)
      }

      if (!response.success) {
        let errorMsg = typeof response.error === 'string' ? response.error : 'Failed to save integration'
        
        if (errorMsg.includes('duplicate key') || errorMsg.includes('unique constraint')) {
          errorMsg = `A webhook integration with the name "${config.name}" already exists. Please choose a different name.`
        }
        
        throw new Error(errorMsg)
      }

      toast.success('Webhook configuration saved successfully')
      onSaved?.()
      onOpenChange(false)
    } catch (error) {
      toast.error('Failed to save configuration')
      console.error(error)
    } finally {
      setLoading(false)
    }
  }

  // Extract content into reusable component for both dialog and page modes
  const renderContent = () => (
    <>
      <Tabs defaultValue="config" className="w-full">
        <TabsList className="grid w-full grid-cols-2">
          <TabsTrigger value="config">Configuration</TabsTrigger>
          <TabsTrigger value="openapi">OpenAPI Spec</TabsTrigger>
        </TabsList>

        <TabsContent value="config" className="space-y-4 py-4">
          <div className="space-y-2">
            <Label htmlFor="name">Integration Name *</Label>
            <Input
              id="name"
              value={config.name}
              onChange={(e) => setConfig({ ...config, name: e.target.value })}
              placeholder="e.g., External Platform Webhook"
            />
          </div>

          <div className="space-y-2">
            <Label>NetNeural Webhook URL (Use this in your external platform)</Label>
            <div className="flex gap-2">
              <Input
                readOnly
                value={ourWebhookEndpoint}
                className="font-mono text-sm"
              />
              <Button
                type="button"
                variant="outline"
                size="sm"
                onClick={() => copyToClipboard(ourWebhookEndpoint)}
              >
                <Copy className="h-4 w-4" />
              </Button>
            </div>
            <p className="text-sm text-muted-foreground">
              Configure this URL in your external IoT platform (Golioth, AWS IoT, etc.) to send webhooks to NetNeural
            </p>
          </div>

          <div className="space-y-2">
            <Label>Integration ID (Add as X-Integration-ID header)</Label>
            <div className="flex gap-2">
              <Input
                readOnly
                value={integrationId || generatedApiKey}
                className="font-mono text-sm"
              />
              <Button
                type="button"
                variant="outline"
                size="sm"
                onClick={() => copyToClipboard(integrationId || generatedApiKey)}
              >
                <Copy className="h-4 w-4" />
              </Button>
            </div>
            <p className="text-sm text-muted-foreground">
              Add this as X-Integration-ID header in your webhook configuration
            </p>
          </div>

          <div className="space-y-2">
            <Label htmlFor="secret">Webhook Secret (Optional)</Label>
            <Input
              id="secret"
              type="password"
              value={config.secret}
              onChange={(e) => setConfig({ ...config, secret: e.target.value })}
              placeholder="Secret from your external platform"
            />
            <p className="text-sm text-muted-foreground">
              If your external platform signs webhooks, enter the secret key here for verification
            </p>
          </div>

          <div className="mt-6 p-4 bg-blue-50 dark:bg-blue-950 border border-blue-200 dark:border-blue-800 rounded-lg">
            <h4 className="font-semibold text-sm mb-2 text-blue-900 dark:text-blue-100">How to Configure</h4>
            <ol className="text-sm space-y-1 text-blue-800 dark:text-blue-200 list-decimal list-inside">
              <li>Copy the NetNeural Webhook URL above</li>
              <li>Go to your external IoT platform's webhook settings</li>
              <li>Add our webhook URL as the destination</li>
              <li>Add X-Integration-ID header with the value shown above</li>
              <li>If your platform requires signature verification, enter the secret key</li>
            </ol>
          </div>
        </TabsContent>

        <TabsContent value="openapi" className="space-y-4 py-4">
          <Card>
            <CardHeader>
              <CardTitle className="text-lg">Webhook Integration Guide</CardTitle>
              <CardDescription>How to receive and verify webhook events</CardDescription>
            </CardHeader>
            <CardContent className="space-y-4">
              <div>
                <h4 className="font-semibold mb-2">1. Endpoint Requirements</h4>
                <ul className="list-disc list-inside text-sm space-y-1 text-muted-foreground">
                  <li>HTTPS endpoint (required for production)</li>
                  <li>Return 200-299 status code for successful receipt</li>
                  <li>Respond within timeout period (default 30 seconds)</li>
                  <li>Handle idempotency - events may be delivered more than once</li>
                </ul>
              </div>

              <div>
                <h4 className="font-semibold mb-2">2. Payload Format</h4>
                <pre className="bg-muted p-4 rounded-lg text-xs font-mono overflow-x-auto">
{`{
  "event": "device.updated",
  "timestamp": "2025-11-16T10:30:00Z",
  "device": {
    "id": "device-uuid",
    "name": "Sensor 001",
    "status": "online",
    "last_seen": "2025-11-16T10:29:55Z",
    "metadata": {
      "temperature": 22.5,
      "humidity": 45
    }
  },
  "organization_id": "org-uuid",
  "integration_id": "integration-uuid"
}`}
                </pre>
                <Button
                  variant="ghost"
                  size="sm"
                  className="mt-2"
                  onClick={() => copyToClipboard(JSON.stringify({
                    event: "device.updated",
                    timestamp: new Date().toISOString(),
                    device: {
                      id: "device-uuid",
                      name: "Sensor 001",
                      status: "online"
                    }
                  }, null, 2))}
                >
                  <Copy className="h-4 w-4 mr-2" />
                  Copy Example
                </Button>
              </div>

              <div>
                <h4 className="font-semibold mb-2">3. Signature Verification (HMAC SHA-256)</h4>
                <p className="text-sm text-muted-foreground mb-2">
                  Verify the X-Webhook-Signature header to ensure authenticity:
                </p>
                <Tabs defaultValue="nodejs" className="w-full">
                  <TabsList>
                    <TabsTrigger value="nodejs">Node.js</TabsTrigger>
                    <TabsTrigger value="python">Python</TabsTrigger>
                    <TabsTrigger value="go">Go</TabsTrigger>
                  </TabsList>
                  <TabsContent value="nodejs">
                    <pre className="bg-muted p-4 rounded-lg text-xs font-mono overflow-x-auto">
{`const crypto = require('crypto');

function verifySignature(payload, signature, secret) {
  const hmac = crypto
    .createHmac('sha256', secret)
    .update(JSON.stringify(payload))
    .digest('hex');
  
  return crypto.timingSafeEqual(
    Buffer.from(signature),
    Buffer.from(hmac)
  );
}

// Express.js example
app.post('/webhook', (req, res) => {
  const signature = req.headers['x-webhook-signature'];
  const isValid = verifySignature(
    req.body, 
    signature, 
    process.env.WEBHOOK_SECRET
  );
  
  if (!isValid) {
    return res.status(401).json({ error: 'Invalid signature' });
  }
  
  // Process webhook...
  res.json({ received: true });
});`}
                    </pre>
                  </TabsContent>
                  <TabsContent value="python">
                    <pre className="bg-muted p-4 rounded-lg text-xs font-mono overflow-x-auto">
{`import hmac
import hashlib
import json

def verify_signature(payload, signature, secret):
    expected = hmac.new(
        secret.encode(),
        json.dumps(payload).encode(),
        hashlib.sha256
    ).hexdigest()
    
    return hmac.compare_digest(signature, expected)

# Flask example
@app.route('/webhook', methods=['POST'])
def webhook():
    signature = request.headers.get('X-Webhook-Signature')
    is_valid = verify_signature(
        request.json,
        signature,
        os.environ['WEBHOOK_SECRET']
    )
    
    if not is_valid:
        return {'error': 'Invalid signature'}, 401
    
    # Process webhook...
    return {'received': True}`}
                    </pre>
                  </TabsContent>
                  <TabsContent value="go">
                    <pre className="bg-muted p-4 rounded-lg text-xs font-mono overflow-x-auto">
{`package main

import (
    "crypto/hmac"
    "crypto/sha256"
    "encoding/hex"
    "encoding/json"
)

func verifySignature(payload []byte, signature, secret string) bool {
    h := hmac.New(sha256.New, []byte(secret))
    h.Write(payload)
    expected := hex.EncodeToString(h.Sum(nil))
    
    return hmac.Equal(
        []byte(signature),
        []byte(expected),
    )
}

func webhookHandler(w http.ResponseWriter, r *http.Request) {
    signature := r.Header.Get("X-Webhook-Signature")
    body, _ := ioutil.ReadAll(r.Body)
    
    if !verifySignature(body, signature, secret) {
        http.Error(w, "Invalid signature", 401)
        return
    }
    
    // Process webhook...
    json.NewEncoder(w).Encode(map[string]bool{
        "received": true,
    })
}`}
                    </pre>
                  </TabsContent>
                </Tabs>
              </div>

              <div>
                <h4 className="font-semibold mb-2">4. Event Types</h4>
                <div className="space-y-2 text-sm">
                  <div className="grid grid-cols-2 gap-2 text-muted-foreground">
                    <code className="bg-muted px-2 py-1 rounded">device.created</code>
                    <span>New device added</span>
                    <code className="bg-muted px-2 py-1 rounded">device.updated</code>
                    <span>Device metadata changed</span>
                    <code className="bg-muted px-2 py-1 rounded">device.deleted</code>
                    <span>Device removed</span>
                    <code className="bg-muted px-2 py-1 rounded">device.status_changed</code>
                    <span>Online/offline status</span>
                    <code className="bg-muted px-2 py-1 rounded">device.telemetry</code>
                    <span>New sensor data</span>
                    <code className="bg-muted px-2 py-1 rounded">alert.triggered</code>
                    <span>Alert condition met</span>
                  </div>
                </div>
              </div>

              <div>
                <h4 className="font-semibold mb-2">5. Testing Your Endpoint</h4>
                <p className="text-sm text-muted-foreground mb-2">
                  Use tools like ngrok for local development:
                </p>
                <pre className="bg-muted p-4 rounded-lg text-xs font-mono">
{`# Start ngrok tunnel
ngrok http 3000

# Update webhook URL to:
https://your-id.ngrok.io/api/webhooks/netneural`}
                </pre>
              </div>
            </CardContent>
          </Card>
        </TabsContent>

        <TabsContent value="openapi" className="space-y-4 py-4">
          <Card>
            <CardHeader>
              <CardTitle className="text-lg flex items-center justify-between">
                OpenAPI 3.0 Specification
                <div className="flex gap-2">
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => copyToClipboard(JSON.stringify(openApiSpec, null, 2))}
                  >
                    <Copy className="h-4 w-4 mr-2" />
                    Copy Spec
                  </Button>
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => {
                      const blob = new Blob([JSON.stringify(openApiSpec, null, 2)], { type: 'application/json' })
                      const url = URL.createObjectURL(blob)
                      const a = document.createElement('a')
                      a.href = url
                      a.download = 'netneural-webhook-openapi.json'
                      a.click()
                    }}
                  >
                    <FileCode className="h-4 w-4 mr-2" />
                    Download
                  </Button>
                </div>
              </CardTitle>
              <CardDescription>
                Import this specification into tools like Postman, Insomnia, or API documentation generators
              </CardDescription>
            </CardHeader>
            <CardContent>
              <pre className="bg-muted p-4 rounded-lg text-xs font-mono overflow-x-auto max-h-96">
                {JSON.stringify(openApiSpec, null, 2)}
              </pre>
            </CardContent>
          </Card>
        </TabsContent>
      </Tabs>

        {testResult && (
          <div className={`p-3 rounded-md flex items-start gap-2 ${
            testResult.success ? 'bg-green-50 dark:bg-green-950 text-green-800 dark:text-green-200' : 'bg-red-50 dark:bg-red-950 text-red-800 dark:text-red-200'
          }`}>
            {testResult.success ? (
              <CheckCircle className="h-5 w-5 mt-0.5 flex-shrink-0" />
            ) : (
              <XCircle className="h-5 w-5 mt-0.5 flex-shrink-0" />
            )}
            <div className="text-sm">{testResult.message}</div>
          </div>
        )}

      <div className="flex justify-end gap-2 pt-4 border-t">
        {integrationId && (
          <Button 
            variant="secondary" 
            onClick={handleTest} 
            disabled={testing || loading}
          >
            {testing && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
            Send Test Webhook
          </Button>
        )}
        <Button variant="outline" onClick={() => onOpenChange(false)}>
          Cancel
        </Button>
        <Button onClick={handleSave} disabled={loading}>
          {loading && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
          Save Configuration
        </Button>
      </div>
    </>
  )

  // Render as page or dialog based on mode
  if (mode === 'page') {
    return (
      <div className="flex-1 space-y-4 p-4 md:p-8 pt-6">
        <div className="flex items-center justify-between mb-6">
          <div>
            <h2 className="text-3xl font-bold tracking-tight">
              {integrationId ? 'Edit' : 'Add'} Custom Webhook Integration
            </h2>
            <p className="text-muted-foreground">Configure your custom webhook settings</p>
          </div>
        </div>

        <Card>
          <CardContent className="pt-6">
            {renderContent()}
          </CardContent>
        </Card>
      </div>
    )
  }

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-4xl max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle>
            {integrationId ? 'Edit' : 'Add'} Custom Webhook Integration
          </DialogTitle>
        </DialogHeader>

        {renderContent()}
      </DialogContent>
    </Dialog>
  )
}
