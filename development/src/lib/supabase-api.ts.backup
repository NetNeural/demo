import { createClient } from './supabase/client'

interface Alert {
  id: string
  title: string
  message: string
  severity: string
  status: string
  deviceName: string
  deviceType: string  /**
   * Get dashboard activity (using alerts as activity feed)
   */
  async getDashboardActivity(limit = 5) {
    const alertsData = await this.getAlerts(limit)
    return {
      activities: alertsData.alerts.map((alert: Alert) => ({
        id: alert.id,
        type: 'alert',
        title: alert.title,
        description: alert.message,
        timestamp: alert.timestamp,
        severity: alert.severity,
        deviceName: alert.deviceName
      }))
    }
  }

  /**
   * Get organizations for the current user
   */
  async getOrganizations() {
    try {
      const headers = await this.getAuthHeaders()
      const url = this.getFunctionUrl('organizations')

      const response = await fetch(url, {
        method: 'GET',
        headers
      })

      if (!response.ok) {
        console.error('Organizations API error:', response.status, response.statusText)
        // Return fallback data
        return {
          organizations: [
            {
              id: '00000000-0000-0000-0000-000000000001',
              name: 'NetNeural Demo',
              slug: 'netneural-demo',
              role: 'admin',
              deviceCount: 4,
              userCount: 1
            }
          ]
        }
      }

      return await response.json()
    } catch (error) {
      console.error('Error fetching organizations:', error)
      // Return fallback data
      return {
        organizations: [
          {
            id: '00000000-0000-0000-0000-000000000001',
            name: 'NetNeural Demo',
            slug: 'netneural-demo',
            role: 'admin',
            deviceCount: 4,
            userCount: 1
          }
        ]
      }
    }
  }

  /**
   * Get integrations for an organization
   */
  async getIntegrations(organizationId?: string) {
    try {
      const headers = await this.getAuthHeaders()
      const url = this.getFunctionUrl('integrations')
      const params = new URLSearchParams()
      
      if (organizationId) {
        params.append('organization_id', organizationId)
      }

      const response = await fetch(`${url}?${params}`, {
        method: 'GET',
        headers
      })

      if (!response.ok) {
        console.error('Integrations API error:', response.status, response.statusText)
        // Return fallback data
        return {
          integrations: [
            {
              id: 'golioth-1',
              type: 'golioth',
              name: 'Golioth Cloud',
              status: 'active',
              lastSync: new Date().toISOString(),
              deviceCount: 4
            }
          ]
        }
      }

      return await response.json()
    } catch (error) {
      console.error('Error fetching integrations:', error)
      // Return fallback data
      return {
        integrations: [
          {
            id: 'golioth-1',
            type: 'golioth',
            name: 'Golioth Cloud',
            status: 'active',
            lastSync: new Date().toISOString(),
            deviceCount: 4
          }
        ]
      }
    }
  } string
  acknowledged: boolean
  acknowledgedBy: string | null
  resolvedAt: string | null
}

class SupabaseAPIService {
  private supabase = createClient()

  /**
   * Get the Supabase function URL for calling edge functions
   */
  private getFunctionUrl(functionName: string): string {
    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL
    if (!supabaseUrl) {
      throw new Error('NEXT_PUBLIC_SUPABASE_URL is not set')
    }
    return `${supabaseUrl}/functions/v1/${functionName}`
  }

  /**
   * Get authentication headers for function calls
   */
  private async getAuthHeaders(): Promise<Record<string, string>> {
    const { data: { session } } = await this.supabase.auth.getSession()
    const headers: Record<string, string> = {
      'Content-Type': 'application/json',
    }
    
    if (session?.access_token) {
      headers['Authorization'] = `Bearer ${session.access_token}`
    }
    
    return headers
  }

  /**
   * Get dashboard statistics
   */
  async getDashboardStats() {
    try {
      const headers = await this.getAuthHeaders()
      const response = await fetch(this.getFunctionUrl('dashboard-stats'), {
        method: 'GET',
        headers,
      })

      if (!response.ok) {
        console.warn(`Dashboard stats API failed with status ${response.status}. Using fallback data.`)
        // Fall through to fallback data
      } else {
        return await response.json()
      }
    } catch (error) {
      console.error('Error fetching dashboard stats:', error)
      console.log('Returning fallback dashboard stats...')
      // Return fallback data
      return {
        devices: { total: 0, online: 0, offline: 0, uptime: '0' },
        alerts: { total: 0, critical: 0, last24h: 0 },
        system: { status: 'unknown', lastUpdated: new Date().toISOString() }
      }
    }
  }

  /**
   * Get devices list
   */
  async getDevices(organizationId?: string) {
    try {
      const headers = await this.getAuthHeaders()
      const url = this.getFunctionUrl('devices')
      const params = new URLSearchParams()
      
      if (organizationId) {
        params.append('organization_id', organizationId)
      }

      const response = await fetch(`${url}?${params}`, {
        method: 'GET',
        headers,
      })

      if (!response.ok) {
        console.warn(`API request failed with status ${response.status}. Using fallback data.`)
        // Instead of throwing, we'll fall through to the fallback data below
      } else {
        return await response.json()
      }
    } catch (error) {
      console.error('Error fetching devices:', error)
      console.log('Returning fallback device data...')
      // Return fallback data instead of propagating error
      return {
        devices: [
          {
            id: 'fallback-1',
            name: 'Demo Temperature Sensor',
            type: 'Temperature Sensor',
            status: 'online',
            location: 'Demo Location',
            lastSeen: '5 minutes ago',
            batteryLevel: 85,
            isExternallyManaged: false,
            externalDeviceId: null,
            integrationName: null
          }
        ]
      }
    }
  }

  /**
   * Get alerts list
   */
  async getAlerts(limit = 10, organizationId?: string) {
    try {
      const headers = await this.getAuthHeaders()
      const url = this.getFunctionUrl('alerts')
      const params = new URLSearchParams()
      
      params.append('limit', limit.toString())
      if (organizationId) {
        params.append('organization_id', organizationId)
      }

      const response = await fetch(`${url}?${params}`, {
        method: 'GET',
        headers,
      })

      if (!response.ok) {
        console.warn(`Alerts API failed with status ${response.status}. Using fallback data.`)
        // Fall through to fallback data
      } else {
        return await response.json()
      }
    } catch (error) {
      console.error('Error fetching alerts:', error)
      console.log('Returning fallback alerts data...')
      // Return fallback data
      return {
        alerts: [
          {
            id: 'fallback-alert-1',
            title: 'Demo Alert',
            message: 'This is a demo alert for offline mode',
            severity: 'info',
            status: 'active',
            deviceName: 'Demo Device',
            deviceType: 'Sensor',
            timestamp: new Date().toISOString(),
            acknowledged: false,
            acknowledgedBy: null,
            resolvedAt: null
          }
        ]
      }
    }
  }

  /**
   * Test integration connection
   */
  async testIntegration(integrationId: string) {
    try {
      const headers = await this.getAuthHeaders()
      const response = await fetch(this.getFunctionUrl(`integration-test/${integrationId}`), {
        method: 'POST',
        headers,
      })

      if (!response.ok) {
        console.warn(`Integration test API failed with status ${response.status}. Returning failure response.`)
        // Fall through to error response
      } else {
        return await response.json()
      }
    } catch (error) {
      console.error('Error testing integration:', error)
      return {
        success: false,
        message: 'Failed to test integration: ' + (error instanceof Error ? error.message : 'Unknown error'),
        details: {}
      }
    }
  }

  /**
   * Get dashboard activity (using alerts as activity feed)
   */
  async getDashboardActivity(limit = 5) {
    const alertsData = await this.getAlerts(limit)
    return {
      activities: alertsData.alerts.map((alert: Alert) => ({
        id: alert.id,
        type: 'alert',
        title: alert.title,
        description: alert.message,
        timestamp: alert.timestamp,
        severity: alert.severity,
        deviceName: alert.deviceName
      }))
    }
  }
}

// Export singleton instance
export const supabaseAPI = new SupabaseAPIService()export const supabaseAPI = new SupabaseAPIService()
